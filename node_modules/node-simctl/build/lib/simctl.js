"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Simctl = void 0;
const lodash_1 = __importDefault(require("lodash"));
const index_js_1 = __importDefault(require("./subcommands/index.js"));
const which_1 = __importDefault(require("which"));
const logger_1 = __importStar(require("./logger"));
const helpers_1 = require("./helpers");
const teen_process_1 = require("teen_process");
const SIMCTL_ENV_PREFIX = 'SIMCTL_CHILD_';
const DEFAULT_OPTS = {
    xcrun: {
        path: null,
    },
    execTimeout: helpers_1.DEFAULT_EXEC_TIMEOUT,
    logErrors: true,
};
/**
 * @typedef {Object} XCRun
 * @property {string?} path Full path to the xcrun script
 */
/**
 * @typedef {Object} ExecOpts
 * @property {string[]} [args=[]] - The list of additional subcommand arguments.
 * It's empty by default.
 * @property {Record<string, any>} [env={}] - Environment variables mapping. All these variables
 * will be passed Simulator and used in the executing function.
 * @property {boolean} [logErrors=true] - Set it to _false_ to throw execution errors
 * immediately without logging any additional information.
 * @property {boolean} [asynchronous=false] - Whether to execute the given command
 * 'synchronously' or 'asynchronously'. Affects the returned result of the function.
 * @property {string} [encoding] - Explicitly sets streams encoding for the executed
 * command input and outputs.
 * @property {string|string[]} [architectures] - One or more architecture names to be enforced while
 * executing xcrun. See https://github.com/appium/appium/issues/18966 for more details.
 */
/**
 * @typedef {Object} SimctlOpts
 * @property {XCRun} [xcrun] - The xcrun properties. Currently only one property
 * is supported, which is `path` and it by default contains `null`, which enforces
 * the instance to automatically detect the full path to `xcrun` tool and to throw
 * an exception if it cannot be detected. If the path is set upon instance creation
 * then it is going to be used by `exec` and no autodetection will happen.
 * @property {number} [execTimeout=600000] - The maximum number of milliseconds
 * to wait for single synchronous xcrun command.
 * @property {boolean} [logErrors=true] - Whether to wire xcrun error messages
 * into debug log before throwing them.
 * @property {string?} [udid] - The unique identifier of the current device, which is
 * going to be implicitly passed to all methods, which require it. It can either be set
 * upon instance creation if it is already known in advance or later when/if needed via the
 * corresponding instance setter.
 * @property {string?} [devicesSetPath] - Full path to the set of devices that you want to manage.
 * By default this path usually equals to ~/Library/Developer/CoreSimulator/Devices
 */
class Simctl {
    /**
     * @param {SimctlOpts} [opts={}]
     */
    constructor(opts = {}) {
        opts = lodash_1.default.cloneDeep(opts);
        lodash_1.default.defaultsDeep(opts, DEFAULT_OPTS);
        for (const key of lodash_1.default.keys(DEFAULT_OPTS)) {
            this[key] = opts[key];
        }
        /** @type {string?} */
        this._udid = lodash_1.default.isNil(opts.udid) ? null : opts.udid;
        /** @type {string?} */
        this._devicesSetPath = lodash_1.default.isNil(opts.devicesSetPath) ? null : opts.devicesSetPath;
    }
    set udid(value) {
        this._udid = value;
    }
    get udid() {
        return this._udid;
    }
    set devicesSetPath(value) {
        this._devicesSetPath = value;
    }
    get devicesSetPath() {
        return this._devicesSetPath;
    }
    requireUdid(commandName = null) {
        if (!this.udid) {
            throw new Error(`udid is required to be set for ` +
                (commandName ? `the '${commandName}' command` : 'this simctl command'));
        }
        return this.udid;
    }
    async requireXcrun() {
        const xcrunBinary = (0, helpers_1.getXcrunBinary)();
        if (!this.xcrun.path) {
            try {
                this.xcrun.path = await (0, which_1.default)(xcrunBinary);
            }
            catch (e) {
                throw new Error(`${xcrunBinary} tool has not been found in PATH. ` +
                    `Are Xcode developers tools installed?`);
            }
        }
        return this.xcrun.path;
    }
    /**
     * Execute the particular simctl command.
     *
     * @param {string} subcommand - One of available simctl subcommands.
     * Execute `xcrun simctl` in Terminal to see the full list  of available subcommands.
     * @param {ExecOpts} [opts={}]
     * @return {Promise<import('teen_process').TeenProcessExecResult|import('teen_process').SubProcess>}
     * Either the result of teen process's `exec` or
     * `SubProcess` instance depending of `opts.asynchronous` value.
     * @throws {Error} If the simctl subcommand command returns non-zero return code.
     */
    async exec(subcommand, opts = {}) {
        let { args = [], env = {}, asynchronous = false, encoding, logErrors = true, architectures, } = opts;
        // run a particular simctl command
        args = [
            'simctl',
            ...(this.devicesSetPath ? ['--set', this.devicesSetPath] : []),
            subcommand,
            ...args
        ];
        // Prefix all passed in environment variables with 'SIMCTL_CHILD_', simctl
        // will then pass these to the child (spawned) process.
        env = lodash_1.default.defaults(lodash_1.default.mapKeys(env, (value, key) => lodash_1.default.startsWith(key, SIMCTL_ENV_PREFIX) ? key : `${SIMCTL_ENV_PREFIX}${key}`), process.env);
        const execOpts = {
            env,
            encoding,
        };
        if (!asynchronous) {
            execOpts.timeout = this.execTimeout;
        }
        const xcrun = await this.requireXcrun();
        try {
            let execArgs = [xcrun, args, execOpts];
            if (architectures?.length) {
                const archArgs = lodash_1.default.flatMap((lodash_1.default.isArray(architectures) ? architectures : [architectures]).map((arch) => ['-arch', arch]));
                execArgs = ['arch', [...archArgs, xcrun, ...args], execOpts];
            }
            // @ts-ignore We know what we are doing here
            return asynchronous ? new teen_process_1.SubProcess(...execArgs) : await (0, teen_process_1.exec)(...execArgs);
        }
        catch (e) {
            if (!this.logErrors || !logErrors) {
                // if we don't want to see the errors, just throw and allow the calling
                // code do what it wants
            }
            else if (e.stderr) {
                const msg = `Error running '${subcommand}': ${e.stderr.trim()}`;
                logger_1.default.debug(logger_1.LOG_PREFIX, msg);
                e.message = msg;
            }
            else {
                logger_1.default.debug(logger_1.LOG_PREFIX, e.message);
            }
            throw e;
        }
    }
}
exports.Simctl = Simctl;
// add all the subcommands to the Simctl prototype
for (const [fnName, fn] of lodash_1.default.toPairs(index_js_1.default)) {
    Simctl.prototype[fnName] = fn;
}
exports.default = Simctl;
//# sourceMappingURL=simctl.js.map